import os
import random
import math
from puit.objects.gameobject import Gameobject
from puit.objects.gameobject import CompositeGameobject
from puit.objects.character import Character
from puit import draw as draw_me_a
from backgroundstuff.twod import Vector2d
from backgroundstuff import graphics
import puit
from pyglet import image

def random_ground(w,h):
  return Level([BufferedAutogeneratedTerrain(w,h)])

def load(name):
  return Level([BitmapTerrain(name+'.png')])

class Level(CompositeGameobject):
  collision_group = 'scenery'
  
  def __init__(self, objects):
    super(Level, self).__init__(objects)
    self.affected_by_gravity = False
  
  def width(self):
    return self.boundingbox.width
  
  def spawn_top(self):
    return self.boundingbox.height - 1 # spawnable lol
  
  def tick(self):
    super(Level, self).tick()
    for part in self.get_parts():
      if not part._mini_graphic_is_valid:
        self._mini_graphic_is_valid = False
        return
  
  def _make_mini_graphic(self, width=None):
    if width is None:
      total_width = puit.gamemaster.scrollarea.width
    else:
      total_width = width
    graphic = image.create(total_width, 10).create_texture(image.Texture)
    x_scale = total_width / float(self.boundingbox.width)
    y_scale = 20.0 / self.boundingbox.height
    for part in self.get_parts():
      part_width = part.boundingbox.width
      part_mini_width = int(round(part_width * x_scale))
      part_graphic = part.get_mini_graphic(part_mini_width)
      part_pos_x = int(round(part.boundingbox.left * x_scale))
      part_pos_y = int(round(part.boundingbox.bottom * y_scale))
      graphic.blit_into(part_graphic, part_pos_x, part_pos_y, 0)
    return graphic
  
  def top_border_at(self, x, y): # TODO: implement this properly!
    for p in self.get_parts():
      if p.boundingbox.contains_point((x, y)):
        return p.top_border_at(x, y)
    return None

class ConquestLevel(Level):
  def __init__(self, width, height, left_team, right_team):
    # TODO clean up this fucking mess and remove the redundancy!
    self._left_team = left_team
    self._right_team = right_team
    flat_section_width = 60
    # don't mess with the following numbers, they're magical
    flat_section_heights = [42, 5, 24]
    half_width = int(width / 2.0)
    curvy_section_width = int((half_width - (2.5 * flat_section_width)) / 2.0)
    x = 0
    parts = []
    p = get_flat_terrain(flat_section_width, height, flat_section_heights[0],
        level_boundary_right=False)
    parts.append(p)
    parts.append(LandingZone((x, flat_section_heights[0]), flat_section_width,
        1, team=self._left_team))
    x += flat_section_width
    p = BufferedAutogeneratedTerrain(curvy_section_width, height,
        level_boundary_left=False, level_boundary_right=False,
        start_height=flat_section_heights[0], end_height=flat_section_heights[1])
    blueprint1 = p.heights[:]
    blueprint1.reverse()
    p.boundingbox.move((x, 0))
    parts.append(p)
    x += curvy_section_width
    p = get_flat_terrain(flat_section_width, height, flat_section_heights[1],
        level_boundary_left=False, level_boundary_right=False)
    p.boundingbox.move((x, 0))
    parts.append(p)
    parts.append(LandingZone((x, flat_section_heights[1]), flat_section_width,
        1, team=None))
    x += flat_section_width
    p = BufferedAutogeneratedTerrain(curvy_section_width, height,
        level_boundary_left=False, level_boundary_right=False,
        start_height=flat_section_heights[1], end_height=flat_section_heights[2])
    blueprint2 = p.heights[:]
    blueprint2.reverse()
    p.boundingbox.move((x, 0))
    parts.append(p)
    x += curvy_section_width
    p = get_flat_terrain(flat_section_width, height, flat_section_heights[2],
        level_boundary_left=False, level_boundary_right=False)
    p.boundingbox.move((x, 0))
    parts.append(p)
    parts.append(LandingZone((x, flat_section_heights[2]), flat_section_width,
        1, team=None))
    x += flat_section_width
    p = BufferedAutogeneratedTerrain(curvy_section_width, height,
        blueprint=blueprint2, level_boundary_left=False, level_boundary_right=False)
    p.boundingbox.move((x, 0))
    parts.append(p)
    x += curvy_section_width
    p = get_flat_terrain(flat_section_width, height, flat_section_heights[1],
        level_boundary_left=False, level_boundary_right=False)
    p.boundingbox.move((x, 0))
    parts.append(p)
    parts.append(LandingZone((x, flat_section_heights[1]), flat_section_width,
        1, team=None))
    x += flat_section_width
    p = BufferedAutogeneratedTerrain(curvy_section_width, height,
        blueprint=blueprint1, level_boundary_left=False, level_boundary_right=False)
    p.boundingbox.move((x, 0))
    parts.append(p)
    x += curvy_section_width
    remaining_width = width - x
    p = get_flat_terrain(remaining_width, height, flat_section_heights[0],
        level_boundary_left=False)
    p.boundingbox.move((x, 0))
    parts.append(p)
    parts.append(LandingZone((x, flat_section_heights[0]), remaining_width,
        1, team=self._right_team))
    super(ConquestLevel, self).__init__(parts)

class LandingZone(Gameobject):
  collision_group = 'scenery'
  ticks_to_takeover = 300
  
  def __init__(self, pos, width, height, team=None):
    super(LandingZone, self).__init__(pos, width, height)
    self.owner = team
    self._set_colours()
    self._registered_teams = set()
    self._ticks_occupied = 0
    self._occupier = None
  
  def _set_colours(self):
    if self.owner is not None:
      col = self.owner.main_colour
      self._colour = (col[0], col[1], col[2], 255)
      self._colour_gl = self.owner.main_colour_gl
    else:
      self._colour = (168, 168, 168, 255)
      self._colour_gl = (0.66, 0.66, 0.66)
    self._mini_graphic_is_valid = False
  
  def draw(self):
    if (self._occupier is None) or ((int(self._ticks_occupied / 7.0) % 2) == 0):
      col = self._colour_gl
    else:
      col = self._occupier.main_colour_gl
    draw_me_a.rect(self.boundingbox, col, puit.gamemaster.scrollarea.bottom_left)
  
  def _make_mini_graphic(self, width):
    return image.create(width, 1, image.SolidColorImagePattern(
        self._colour))
  
  def collide_with(self, gameobject, parts=None):
    base_height = gameobject.boundingbox.bottom
    x = gameobject.boundingbox.center_x
    if base_height < self.boundingbox.top:
      base_height = self.boundingbox.top
      gameobject.collided_with(self, 'landingzone')
      gameobject.set_mid_bottom((x, base_height))
    if isinstance(gameobject, Character):
      if (self.owner is None) or (self.owner is not gameobject.team):
        self._registered_teams.add(gameobject.team)
  
  def tick(self):
    super(LandingZone, self).tick()
    if len(self._registered_teams) == 1:
      if (self.owner is None) or (self.owner not in self._registered_teams):
        # only one team is here, and they're not owner already, so they will
        # attempt to take over!
        if (self._occupier is None) or (self._occupier not in self._registered_teams):
          # this team hasn't been taking over so far. begin now:
          self._ticks_occupied = 0
          self._occupier = self._registered_teams.pop()
        else: # the registered team is already occupying
          self._ticks_occupied += 1
          if self._ticks_occupied >= self.ticks_to_takeover:
            self.owner = self._registered_teams.pop()
            self._occupier = None
            self._set_colours()
            self._ticks_occupied = 0
      else:
        # present team already owns the place ... just to be sure:
        self._ticks_occupied = 0
        self._occupier = None
    else: # no occupying possible now
      self._ticks_occupied = 0
      self._occupier = None
    self._registered_teams.clear()
    

class Terrain(Gameobject):
  collision_group = 'scenery'
  
  def __init__(self, width, height, level_boundary_left=True,
      level_boundary_right=True):
    super(Terrain, self).__init__((0, 0), width, height)
    self.affected_by_gravity = False
    self._level_boundary_left = level_boundary_left
    self._level_boundary_right = level_boundary_right
  
  def draw(self):
    raise NotImplemented
  
  def collide_with(self, gameobject, parts):
    raise NotImplemented
  
  #def collides_with_point(self, position):
  #  return position[1] >= self.top_border_at(position[0])
  # FIXME: is this used anywhere? commenting it out to check, get rid of it

  def constrain_position_to_boundaries(self, x):
    left = self.boundingbox.left
    if self._level_boundary_left and (x < left):
      return left
    right = self.boundingbox.right
    if self._level_boundary_right and (x >= right):
      return right - 1
    return x

  #def clamp_position(self, x):
  #  max_x = self.boundingbox.width - 1
  #  if x < 0:
  #    return 0
  #  elif x > max_x:
  #    return max_x
  #  return x
  # FIXME: is this used anywhere? commenting it out to check, get rid of it

  #def right_boundary(self):
  #  return self.boundingbox.width - 1
  # FIXME: is this used anywhere? commenting it out to check, get rid of it

  #def out_of_level(self, position):
  #  return position[0] != self.constrain_position_to_boundaries(position[0])
  # FIXME: is this used anywhere? commenting it out to check, get rid of it

  def width(self):
    return self.boundingbox.width
  
  def spawn_top(self):
    return self.boundingbox.height - 1 # spawnable lol


class AutogeneratedTerrain(Terrain):
  def __init__(self, width=400, height=120, **kwds):
    if 'blueprint' in kwds:
      self.heights = kwds['blueprint'][:]
      del kwds['blueprint']
      super(AutogeneratedTerrain, self).__init__(width, height, **kwds)
    else:
      start_height = None
      end_height = None
      if 'start_height' in kwds:
        start_height = kwds['start_height']
        del kwds['start_height']
      if 'end_height' in kwds:
        end_height = kwds['end_height']
        del kwds['end_height']
      super(AutogeneratedTerrain, self).__init__(width, height, **kwds)
      self.heights = self._generate_height_map(5, 23, 40, start_height, end_height)
    self.terrain_graphic = graphics.get_image(os.path.join('data', 'level.png'))
    self._mini_terrain_graphic = graphics.get_image(os.path.join('data',
        'level-mini.png'))
  
  def _generate_height_map(self, min, max, smoothing, start_height=None,
      end_height=None):
    heights = []
    left_height = random.randint(min, max + 1)
    while len(heights) < self.boundingbox.width:
      right_height = random.randint(min, max + 1)
      h = [int(left_height * ((smoothing - i) / float(smoothing))
       + right_height * (i / float(smoothing))) for i in xrange(smoothing)]
      heights.extend(h)
      left_height = right_height
    heights = heights[:self.boundingbox.width]
    if smoothing > 4:
      min = int(min / 3) # explicit casts to int for p3k compatibility
      max = int(max / 4)
      smoothing = int(smoothing / 3)
      finer_heights = self._generate_height_map(min, max, smoothing)
      for i in xrange(self.boundingbox.width):
        heights[i] += finer_heights[i]
    for i in xrange(1, self.boundingbox.width):
      if heights[i] > heights[i - 1]:
        heights[i] = heights[i - 1] + 1
      elif heights[i] < heights[i - 1]:
        heights[i] = heights[i - 1] - 1
    if (start_height is None) and (end_height is None):
      return heights
    if start_height is None:
      start_height = heights[0]
      start_correction = 0
    else:
      start_correction = start_height - heights[0]
    if end_height is None:
      end_height = heights[self.boundingbox.width - 1]
      end_correction = 0
    else:
      end_correction = end_height - heights[self.boundingbox.width - 1]
    width = self.boundingbox.width
    for x in xrange(width):
      ratio = float(x) / (width - 1)
      correction = int(start_correction * (1.0 - ratio) + end_correction * ratio)
      heights[x] += correction
    heights[0] = start_height
    for i in xrange(1, self.boundingbox.width):
      if (heights[i] > heights[i - 1] + 1) \
          or ((end_height - heights[i - 1]) >= (width - i)):
        heights[i] = heights[i - 1] + 1
      elif (heights[i] < heights[i - 1]) \
          or ((heights[i - 1] - end_height) >= (width - i)):
        heights[i] = heights[i - 1] - 1
      if heights[i] < 5:
        heights[i] = 5
    return heights
  
  def _generate_mini_heights(self, width):
    heights = []
    big_length = len(self.heights)
    mini_length = width
    big_index = 0
    for x in xrange(mini_length):
      progress = float(x + 1) / mini_length
      sum = 0
      count = 0
      while (float(big_index) / (big_length - 1)) < progress:
        sum += self.heights[big_index]
        count += 1
        big_index += 1
      try:
        heights.append(sum / float(count))
      except ZeroDivisionError:
        heights.append(heights[-1])
    return heights
    
  # def on_ground(self): # WTF was that? i guess we can throw it out.
  #   return True
  
  #def draw(self):
  #  position = Vector2d(puit.gamemaster.scrollarea.bottom_left)
  #  position.clamp((0,0),(self.boundingbox.width, self.boundingbox.height))
  #
  #  for i in range(int(position.x), int(position.x + puit.gamemaster.scrollarea.width + 1)): # +1 is here because i don't want to search where ceil() is
  #    if i >= self.boundingbox.width:
  #      break
  #    # OMG those ~200 blits() we generate here turn 60fps into 30. ZOMG!
  #    self.terrain_graphic.blit(int(i - puit.gamemaster.scrollarea.left),
  #        int(self.heights[i] - puit.gamemaster.scrollarea.bottom - self.terrain_graphic.height))
  
  def draw(self):
    # we'd need new code for this, but we're only using the buffered version
    # of this class anyways, and that doesn't need this draw method, so:
    raise NotImplemented
  
  def _make_mini_graphic(self, width):
    heights = self._generate_mini_heights(width)
    graphic = image.create(width, 10).create_texture(image.Texture)
    y_scale = 20.0 / self.boundingbox.height
    bar = self._mini_terrain_graphic
    for x in xrange(len(heights)):
      y = int(math.ceil(heights[x] * y_scale))
      region = bar.get_region(0, bar.height - y, bar.width, y)
      graphic.blit_into(region, x, 0, 0)
    return graphic.image_data
  
  def collide_with(self, gameobject, parts=None):
    base_position = list(gameobject.boundingbox.mid_bottom)
    xold = base_position[0]
    base_position[0] = self.constrain_position_to_boundaries(base_position[0])
    if not self.boundingbox.contains_point(base_position):
      return # not our department!
    top = self.top_border_at(*base_position)
    if base_position[1] < top:
      base_position[1] = top
      gameobject.collided_with(self, 'ground')
      
    if xold != base_position[0]:
      if base_position[0] == 0:
        gameobject.collided_with(self, 'world boundaries', 'left') # send this as second collision if we hit it
      else:
        gameobject.collided_with(self, 'world boundaries', 'right') # send this as second collision if we hit it
    gameobject.set_mid_bottom(base_position)
  
  def top_border_at(self, x, y):
    try:
      return self.heights[int(x - self.boundingbox.left)]
    except IndexError:
      print x, y, self.boundingbox, int(x - self.boundingbox.left), len(self.heights)
      raise
  
  def height_terrain_to_world(self, height):
    return self.boundingbox.height - height

  def height_world_to_terrain(self, y):
      return self.boundingbox.height - y

class BufferedAutogeneratedTerrain(AutogeneratedTerrain):
  """
  same as AutogeneratedLevel, but this time we're buffering the level graphic to a texture
  to avoid drawing a lot of small textures each frame
  """
  def __init__(self, width=400, height=300, **kwds):
    super(BufferedAutogeneratedTerrain, self).__init__(width, height, **kwds)
    self.buffer_image = image.create(self.boundingbox.width,
        self.boundingbox.height).create_texture(image.Texture)
    
    for i in range(0, self.boundingbox.width):
      y = self.heights[i]
      region = self.terrain_graphic.get_region(0, self.terrain_graphic.height-y,
          self.terrain_graphic.width, y)
      self.buffer_image.blit_into(region, int(i), 0, 0)

  def draw(self):
    self.buffer_image.blit(int(self.boundingbox.left - puit.gamemaster.scrollarea.left),
        int(self.boundingbox.bottom - puit.gamemaster.scrollarea.bottom))

def get_flat_terrain(width, height, ground_height, **kwds):
  blueprint = [ground_height for i in xrange(width)]
  return BufferedAutogeneratedTerrain(width, height, blueprint=blueprint, **kwds)

class BitmapTerrain(Terrain):
  # CAUTION! i'm not quite done converting BitmapTerrain so it properly works
  # as a part of a Level. it'll probably work if it's located at (0, 0) in the
  # level, but for other cases i have to make some adjustments.
  def __init__(self, filename):
    self.terrain_graphic = graphics.get_image(os.path.join('data', 'level', filename))
    
    super(BitmapTerrain, self).__init__(self.terrain_graphic.width, self.terrain_graphic.height)

    # todo: use pynumeric
    self.pixels = graphics.Pixelmap(self.terrain_graphic)
    
    w,h = self.terrain_graphic.width, self.terrain_graphic.height
    self.collision_map = [ [None]*w for i in range(h) ]
    
    for x in range(0, self.terrain_graphic.width):
      for y in range(0, self.terrain_graphic.height):
        if self.pixels.pixel_at(x,y)[3] != chr(0):
          self.collision_map[y][x] = True
        else:
          self.collision_map[y][x] = False
      
  # def on_ground(self): # WTF was that? i guess we can throw it out.
  #   return True

  def draw(self):
    self.terrain_graphic.blit(int(self.boundingbox.left - puit.gamemaster.scrollarea.left),
        int(self.boundingbox.bottom - puit.gamemaster.scrollarea.bottom))

  def top_border_at(self, x, y):
    for yt in range(int(y), self.terrain_graphic.height): # FIXME: OMGWTF? why not cache this?
      if not self.collision_map[int(yt)][int(x)]:
        break
    return yt - 1

  def collide_with(self, gameobject, parts=None):
    x, y = gameobject.boundingbox.center_x, gameobject.boundingbox.bottom
    if x < 0:
      gameobject.collided_with(self, 'world boundaries', 'left') # send this as second collision if we hit it
      x = 0
    if x >= self.terrain_graphic.width:
      gameobject.collided_with(self, 'world boundaries', 'right')
      x = self.terrain_graphic.width - 1
    if y >= self.terrain_graphic.height:
      return
    if y < 0:
      # TODO: HACK: this hides the "fall through floor when velocity is too high" bug from players
      # FIXME: actually it doesn't really hide it, it glitches like crazy
      y = self.top_border_at(x, 0)+1
    # TODO: check along the whole traveled path y-wise. otherwise we can fall through floors
    if self.collision_map[int(y)][int(x)] == True:
      top = self.top_border_at(x, y)
      move_up = top - y
      if gameobject.velocity[1] < 0 and move_up < 5:
        gameobject.collided_with(self, 'ground')
        y = top + 1
      else:
        gameobject.collided_with(self, 'world boundaries')
        x -= gameobject.velocity[0]
    gameobject.set_mid_bottom((x, y))