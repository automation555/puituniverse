# REVISION NOTES #

as opposed to release notes, these are not for users, but for internal
communication between developers. before committing something to the repo,
always do 'svn up' and make sure to get rid of conflicts, if there are any.
when 'svn up' gave you a new revision, this file is where you look to figure
out what has changed, and why.

## revision 74 (nex):
- adapted (Buffererd)AutogeneratedTerrain a bit so it now works properly both
  inside a Level and also stand-alone. BitmapTerrain will stell need a tiny
  bit of work to get it there; mostly that'll just consist of looking at how
  things are now done in the auto-generated terrains and imitating that.
  however, in both classes there still are some pieced of code that assume
  that a terrain is something stuff _resides in_, instead of something _on_
  which stuff may stand/sit/lie. fixing this will bring more flexibility to
  our level-putting-together-ing, bit doing so will be easier once we handle
  world boundaries in a smarter way. i'm planning to have terrain pieces not
  care about world boundaries at all, instead i want to have four large
  'boundary' objects enclosing the level. when something collides with one
  of those objects (left, right, bottom, top), it is pushed back inside and
  and correct collision event is generated. easy peasy.(TODO!)
- bug workaround: i've figured out a pretty surefire way of falling through
  the bottom of auto-generated terrain. it involved jumping and landing on
  a very shallow part. i have eliminated this possibility for now simply by
  jacking up the minimum height of terrain a bit.
- extended auto-generated terrain parts so they can now duplicate or mirror
  the shape of other terrain parts and also shear in order to reach a
  certain start and/or end height. this allows a piece of terrain to
  seamlessly bridge two adjacing ones with given heights. a new utility
  function makes perfectly flat terrain parts on which structures and landing
  zones can be based. the new version of ConquestLevel makes use of all this.
- made a LandingZone class and added landing zones to the conquest level.
- d'oh, i forgot to include a file in the previous revision. i'm not quite
  done yet with what i'd planned for this one, but it should work and now
  has the conquest module.

## revision 73 (nex):
- got rid of collisions with 'air'. once levels are composed of multiple
  'terrain' objects, i want to be able to make their bounding boxes so small
  that they only include the terrain itself and as little 'air' as possible,
  i.e. there will be areas that contain _nothing_ as far as level data is
  concerned. the reason is simple: smaller bounding boxes mean fewer
  collisions. considering that often we have more bullets than all other
  types of object combined and that bullets are in the 'air' most of the time,
  this should be quite good for performance. however, collisions with 'air'
  were previously used to set the 'on_ground' state of game objects. this
  still works, but i had to update the implementation and it now exploits the
  fact that Gamestate._tick_objects() does _collide_objects() before
  tick()ing the individual objects. _never_ change this order of doing things
  unless you _really_ know what you're doing!
- started to implement the new CompositeGameobject class, on which i'll base
  the new Level class. actually it would be a bit overkill just for this
  purpose, however i'm assuming that it'll be useful for Characters as well.
  it'll be easy to make equipment stuff Gameobjects in their own right, which
  automatically move along with their 'owner' objects. dito for the planned
  accessories for customising player characters. as a result, the collision
  detection system has changed a bit.
- changed Character to inherit from CompositeGameobject instead of
  Gameobject. this isn't strictly necessary just yet (equipment objects
  aren't separate Gameobjects yet), but it was the best place to start testing
  the (partially completed) CompositeGameobject implementation. these changes
  might seem a bit useless when seen as refactoring, but there's more to them.
  when i'm done with this, you'll be able to say in a couple of lines of code
  that someone in your fireteam should pick up an itemcrate and carry it
  along for you. plus, there's one more thing ... which i'll reveal when it's
  done. also, note that because equipment objects aren't real Gameobjects yet,
  they are now owned not by a Character, but by a CharacterBody. this is odd,
  and has resulted in more stupid-looking lines of code than i would've
  thought, however this is only temporary. as soon as i've fixed this,
  characters will own their equipment again, and the stupidity will go away.
  in finishing this step, i completed most of CompositeGameobject's
  implementation.
- finished extending the collision system to work with CompositeGameobjects.
  now they can be colliders, too, instead of just targets.
- with the extended collision system ready and the CompositeGameobject class
  implemented to a sufficient degree (i still have to add functionality for
  adding/removing objects to a CompositeGameobject on the fly), i was able to
  bring the Level class back. it now is a CompositeGameobject that contains
  a terrain object. but it is also able to contain more than that! this means
  we can now add factories or helipads and whatever else we like. it's also
  possible to have multiple terrain objects in a level, which is neat because
  it's easier to plug together a level from multiple simple terrain objects
  than making one really complex terrain object.
- refined the implementation for running backwards while shooting. you still
  trigger running backwards by holding the shoot button while changing
  directions, but if you continue running without shooting, you'll turn around
  and face forwards again. you can turn around instantly by re-pressing the
  forward movement key while leaving the shoot button unpressed.

## revision 72 (nex):
- players can run backwards again. you start running backwards by pressing
  the appropriate arrow key (left or right) while holding the shoot key.
  you will keep on running backwards as long as you hold that arrow key, i.e.
  while you do so, you can tap the shoot button, and shoot while running
  backwards. AiPlayers don't make use of this technique yet. we'll have to
  refine this feature somewhat, especially for arcade mode; but for conquest
  mode, it already makes a lot of sense as it is.
- glitch workaround: auto-generated levels weren't rendered correctly at
  places with too great heights. so far i had avoided this by restricting
  heights to a range that worked. now it is possible to use a greater range;
  i have simply enlarged the level.png graphic.
- refactoring: in the two 'Level' classes, i swapped out all instances of the
  string 'level' for 'terrain', and changed the classes so now they inherit
  from a new class 'Terrain'. this allowed me to factor out most of what they
  had in common and reduce redundancy in the code. it's now called 'terrain'
  firstly because the current level classes didn't really contain
  everything that makes up a level, and secondly because i'm going to need
  the ability to have multiple pieces of terrain in a level. one neat thing
  you can do with multiple terrain objects in a level is making a 'streaming'
  level, i.e. it can go on forever (imagine an arcade mode where you're
  endlessly going to the right) while the actual amount of terrain loaded at
  any one moment is rather more limited. for now, though, i simply want this
  so i can piece multiple AutogeneratedLevels together. doing this means that
  we can make much more complex levels, while the level/terrain class itself
  only needs to become a tiny bit more complex. to complete the refactoring
  for now, i just made 'random_ground' and 'load' return terrains instead of
  levels; the Level class is currently not used. i'll write the new Level
  class as soon as i've implemented the CompositeGameobject class.
- we need to troubleshoot the broken itemcrate graphic that shows up under
  windows. there are several possibilities how this could be happening. in
  order to locate the problem, i have now added an assertion to
  ItemcrateDrawer.__init__(). someone please run the game under windows and
  find out whether the game aborts with an AssertionError when a crate shows
  up, or continues without an error. make sure you aren't running the python
  interpreter with the -O option; this would prevent the assertion from being
  evaluated.

## revision 71 (nex):
- started to implement conquest mode. in the menu, i swapped it in for
  sidekick mode, because eventually we won't need the latter -- the sidekick
  should just play in arcade mode when no human player 2 is present. the new
  Conquest class is still mostly a copy&paste of Arcade, but that's OK; most
  of it will change soon.
- gamestate's get_all method is already consuming a fair amount of CPU and
  in conquest mode it's going to become even more busy. therefore, i've
  changed it to be just a proxy and call a method with the same signature
  that's attached to a gamestate's object collection. i've added get_all to
  the ObjectCollection interface and implemented it for all three of the
  ObjectCollection implementations we have at the moment. for now this will
  hardly speed things up, if at all, however now it's possible to change the
  ObjectCollection implementations to cache ready-made lists for each object
  class and update them only during 'add' and 'remove' operations. i'm
  planning to do something very similar for when you want all objects in one
  collision group instead of all instances of one class. the object collection
  only holds references to all objects, so it's quite small in terms of
  memory footprint. therefore, holding two or three references to each object
  is the way to go, as it'll greatly improve speed and allow us to do all
  sorts of stuff in the AI. of course great care has to be taken to keep
  everything consistent when you store the same information redundantly in
  several ways, which is why i'm rolling this change out slowly instead of all
  at once. when it's done we can modify the rendering code so it doesn't
  draw objects in a random order, but in a more ordered way. once similar
  objects are drawn in batches, grouped together, we can reduce the frequency
  of OpenGL state changes. for example, we can turn texturing off before
  bullets and particles are rendered, and turn it back on afterwards.
- factored the redundant drawing code for bullets and particles out into
  puit.draw.rect.
- with the new get_all method and the new rectangle drawer, i made a 'radar'
  display for conquest mode, which shows the positions of characters as dots.
  -- radar also shows a silhouette of the terrain.
  -- radar also shows item crates, which blink a bit.
  -- radar also highlights the scrollarea, so you can find yourself on the
     mini-map more quickly.

## revision 70 (nex):
- changed the design of the numerals in our font.
- finished offset adjustment: weapons graphics are now at correct height
  again when ducking, and shots are at correct heights, too.

## revision 69 (oneup):
- turned vsync back on beacuse there was visible tearing.

## revision 68 (oneup):
- adjusted offsets for weapons and parachute in .ini files.

## revision 67 (nex):
- bugfix: turning on profile mode now works again without turning on self-test
  mode.
- added fps display to fixed_resolution.py example. i'd thought i'd found
  something that slowed the resolution-scaling down, so i wanted to see the
  fps before making changes, for comparison. turned out that the changes i'd
  have made were implemented already. it's odd that i only get ~50fps in
  fullscreen mode, especially considering that i get ~74fps in windowed mode.
  hmm, could be vsync, let's try turning vsync off ... now windowed mode has
  ~150fps, but for fullscreen mode it didn't help much. oh, here's what's
  happening: the fixed_resolution example doesn't specify the target
  resolution (to which it renders) anywhere, so the window has a default
  640x480 size, whereas fullscreen mode runs at 1440x1080 here. this explains
  the discrepancy, but something must still be suboptimal here.
- bugfix:
  def is_nearest_goodie_to_the_left(self):
    return False # NOT YET
  ouch! that was super bad. the correct way to do this would've been to change
  is_goodie_present. as it is now, the AiPlayer/AiBuddy knows that there is
  a goodie, but _always_ thinks it is to the right, because this method says
  it's not to the left. this is why the doods were so eargerly running into
  the right corner all the time ... i undid this change to end this silly
  behaviour. i'll implement a proper way of turning off goodie seeking as soon
  as i've (or someone else has) thought of one.
- changed class Boundingbox so the axes are now orieted as in GL and pyglet,
  and x, y, width, height are now accessed via properties. this didn't change
  anything about the mathematics of bounding boxes, it's just a matter of
  nomenclature; e.g. is the point (x, y) the top left or the bottom left
  corner? i think it's helpful for this to be consistent throughout the entire
  code. another question is: wouldn't it be helpful to have (x, y) be in the
  centre of the box? or should it be a corner? i decided to avoid this
  question by making the x, y values purely internal -- you can access either
  the centre (spelled 'center' in the code, since it had already been that
  way -- even though in other places we have 'colour' ...) or a corner. N.B.
  we can't avoid that question altogether, since we have to choose what to do
  when the width or height of the box is modified: will a corner stay in
  place, changing the other three, or will the centre stay in place? for now
  i have decided to keep the lower left corner in place. another open question
  is whether to work with integers or floats. in the old version, there were
  ambiguous pieces of code, e.g. 'self.width/2'. i decided that i'll interpret
  this like current python versions do and use integers everywhere. then i
  realized that, in some places, the code uses Boundingboxes with floats. for
  now i've fixed it so that it works just as well as before, but it's not
  entirely correct yet. (i.e. it didn't really work well before.)
  here's what i did exactly:
  -- where (x, y) coordinates are assigned to one variable, tuples are now
     used instead of lists or Vector2D or anything. yes, for good reasons :-)
     e.g. i can have functions returning tuples that are used strictly
     internally -- they're immutable, so nothing bad will happen, no need to
     make copies of everything, just to make sure.
  -- the first parameter of Boundingbox.__init__ is now called 'lowerleft'.
     this allows you to set the position of the box, and also reminds you
     that the origin of the coordinate system is now in the lower left corner!
     sometimes you might want to use a box only for storing a width and
     height, so lowerleft has a default parameter of (0, 0).
  -- for the remaining parameters, you either have to pass a width/height
     tuple into 'size', or the individual values into 'width' and 'height'.
     maybe eventually the Boundingbox can be initialised with any combination
     of parameters, as long as a position and size can be inferred from them.
     (e.g. specify two opposite corners.)
  -- the box is now manipulated through properties (managed attributes). i.e.
     you no longer have to explicitly call a set_top or set_whatever method,
     you just assign to a property (e.g. top, top_left, center) and all the
     other properties are automagically updated. list of available properties:
     --- size: 2-tuple of (width, height)
     --- width, height: scalar values for width and height
     --- center, top_left, top_right, bottom_left, bottom_right, mid_left,
         mid_right, mid_top, mid_bottom: 2-tuples describing certain points
     --- left, right, top, bottom, center_x, center_y: scalar position
         measurements
  -- i also changed a fine point of the box's semantics a bit: it is logical
     that box.right == box.left + box.with. but this means that when you
     look at the four edges that describe the box, the pixels addressed by the
     two far edges (top, right) actually must not be part of the box! for
     example, if a box is positioned at (0, 0), box.left == 0 and
     box.width == 3, then box.right == 3. since box.width == 3, the box covers
     three pixel columns: 0, 1, 2. no part of column 3 is part of the box!
     this means that when the right border of one box coincides with the left
     border of another box, they do NOT intersect. this makes mathematical
     sense: the borders of boxes aren't really columns or rows of pixels, but
     lines _in between_ pixels, and infinitely thin. therefore, i've changed
     the expression that tests for intersection somewhat:
     return not (other.left >= self.right
         or other.right <= self.left
         or other.bottom >= self.top
         or other.top <= self.bottom
       )
  -- renamed the method 'add' to 'move', since this name makes it more clear
     that we're modifying the object in-place.
  this got rid of the TODO/FIXME comments in the Boundingbox class. in order
  to make the program use the new class, i had to make many little changes all
  over the place. it was a lot of work, but worth it; the code is already
  a bit clearer and now there are opportunities for further simplification.
  i'm also ready to fix the scrolling now (which relies heavily on bounding
  boxes of course.)
- bugfix: when i had written the AiPlayer class, i had assumed that
  Boundingbox depends on pyglet code, and since pyglet.org (with the API docs)
  was down, i hadn't researched that class at all and deliberately left in a
  slight inaccuracy in the method for detecting approaching enemy bullets.
  this is now fixed. however, the method still only really works on very flat
  landscapes.
- improved scrolling:
  -- Mainloop's scroll_to method now covers larger distances by gliding
     smoothly instead of jumping abruptly. the code is still a bit convoluted
     and should be refactored, but visually it looks rather slick.
  -- much more importantly, the scrolling code can now properly handle
     multiple players! AiBuddies (and, later, team-mates joining in over the
     network) do no longer have an effect on the position of the scroll-area.
     Player objects controlled by humans looking at the local screen are now
     all considered equally and made to fit on the screen. if the scroll-area
     has some room to move around while still containing all relevant players,
     it also considers in which direction they are facing -- if everyone looks
     to the right, more of the level to the right of the players will be
     shown.
     --- horizontally, all 'local human' players should fit into one
         scroll-area, therefore the maximum distance allowed between any two
         such players should be the width of the scroll-area. this is not
         enforced yet! however, it should be enforced soon; when you've maxed
         out that distance, you just can't walk any further. up to a certain
         point, an alternative would be to make the view zoom out.
     --- once we really have four players on one screen, the look-ahead code
         could use some sophistication. when i face the left side and thus
         want to look to the left, it makes a difference whether i'm the
         leftmost or rightmost guy of the pack!
  -- so now you can push the view around by turning to face the other side.
     and the smooth gliding described above makes this feature really shine.
     totally worth the ~ 200 extra LoC.
- bugfix: i have another larger chunk of work ahead of me, but first i want
  to get rid of that nasty bug that gets players stuck in the ground. at first
  it looked to me as if the switch from jumping state to standing/running
  state hadn't been made properly, as you're drawn with the 'falling down'
  animation when you're stuck in the ground. turns out that the player object
  doesn't really distinguish between these states at all (maybe this is a bug
  in itself?), it's just that the animation shown depends on the vertical
  velocity. doing some testing, trying to reproduce the bug, i notice that
  it's a side effect of falling through the floor and being pushed up again.
  as the code responsible for this is just a crude, temporary hack, it doesn't
  make much sense to fix that. but there's another attack vector against this
  bug: the cause is that you fall through the floor when you're falling too
  fast, and you're falling too fast when you start out falling from high up.
  this, in turn, is achieved by respawning and immediately shooting, which
  makes you throw away your parachute. now that shouldn't happen, right? if
  you can survive a fall from way up there, why use a 'chute at all? i'd
  propose the following solution: it _should_ be allowed to deliberately shed
  the 'chute, so, when you want, you can speed up your descent. however, if
  you shed the parachute too high up and end up impacting the ground at too
  high a velocity, you end up as a puddle of goo on the ground and die. as
  this way of dieing isn't implemented yet, i've implemented a different fix
  for now: while you're on the 'chute, you can't shoot, period.
- the last big thing i'd planned for this revision is a better collision
  detection system. to make the test fair, i've dialled the scale_factor all
  the way down to 1 (as the blitting isn't optimized yet and might lose time
  at higher scale factors). when 20 or 30 enemies are on the screen and i'm
  using the minigun, the frame rate can easily drop down to 10fps on my G4. as
  the speed of the entire game depends on the frame rate, this is completely
  unacceptable.
  -- first of all, as oneup said, this is ugly:
     Gamestate.collideable_objects = {
       'scenery': [],
       'bullets': [],
       'targets': [],
       'goodies': [],
       'debris': []}
     therefore, i changed the code to put all objects in Gamestate.objects,
     and only there.
  -- in order to gain some flexibility for optimization, i changed
     Gamestate.objects from a list to a custom container type:
     puit.state.objectcollection.ObjectCollection. running the game like this,
     with about 100 objects, gave me < 10fps. don't worry, this was expected.
  -- next, i changed the code so the ObjectCollection itself figures out which
     of its objects collide; you use that property like so:
     for gameobject_collider, gameobject_target in gameobjects.collisions:
     schweet!
  -- then i set about doing what i've been wanting to do all along, and spent
     about two hours converting ObjectCollection so it'll store its objects
     in a recursive tritree structure. inserting and deleting objects worked
     great, but when it came to updating the structure (so moving objects
     are relocated to the relevant tritree nodes) and i did some research
     about what the best approach to this might be, i found out that these
     kinds of data structure are really efficient for _static_ data sets, but
     not really suited for moving objects. i've assumed right from the start
     that i won't sort fast-moving objects like bullets very deep into the
     tree, if at all, but if relocating the other objects is so slow that i
     could just as well rebuild the entire tree each frame, that would suck.
     there are some tricks that can be implemented, e.g. predicting when an
     object will leave a tree node and updating that prediction only when
     necessary (e.g. object's trajectory changes). first i'll have to test how
     the vanilla implementation performs.
  -- now that this has turned into an experiment anyways, i'm having some fun:
     when a Boundingbox that belongs to an object in an ObjectCollection is
     moved or resized, it now automatically notifies its containing tree node,
     and, if necessary, the object is then relocated in the tree. well, turns
     out implementing this is NO fun at all, at the end of the day.
     implementing tritree insertion and removal is easy enough, and the
     relocation technique i just mentioned wasn't that hard either. however,
     then i needed the code to query the structure for collisions, doing as
     new unnecessary tests as possible, and this is fairly complex. it took me
     an ETERNITY to think this through properly and ensure it'll work in all
     situations. (well, let's say until i've written more unit tests, i'm 99%
     sure.)
  -- with the tritree implementation completed, i could go about massively
     paring down the number of collision pairs being returned when querying
     ObjectCollection.collisions. now, instead of checking roughly n**2
     collisions (where n is the number of living game objects), we're checking
     roughly n*2. this difference is fantastic in principle, but in practice,
     as expected, the overhead of updating the tritree is significant. so here
     cometh the moment of truthiness: can i reduce the overhead by limiting
     the depth to which the shorter-lived objects are sorted into the tree?
  -- time to bring collision groups back. not, as previously, for storing
     objects from different groups separately; rather, just to see what can
     collide with what, and maybe to guide tree sorting. to get one step away
     from hardcoding things, i'm now describing which group collides with
     which other groupes (potentially including itself) with a dict. a further
     step will be to generate that dict automatically from the game objects
     provided. then we'll have all the power of Gameobject.can, without the
     big performance penalty. the length of ObjectCollection.collisions is now
     down to about the total number of objects in the system. only a reduction
     by factor 2, but excluding many objects based on their type also means
     that we're skipping many expensive calls to Boundingbox.intersects.
     (actually, now that i'm writing it down ... these shouldn't be that
     expensive, i already have an idea for speeding them up ...)
  -- performance fix: when you had fetched an iterator over an
     ObjectCollection (e.g. for object in collection), previously it had
     compiled a list of all objects it contained, directly and indirectly.
     this was to make it foolproof to use: even if the internal structure
     changed, the iterator was still valid, so you could add and delete while
     iterating. turns out this solution was a bit slow. now, the iterator
     accesses the real thing again, but adds and removes are delayed until
     after all iterators have finished; i.e. it's still foolproof. on my first
     attempt i implemented the iterator with a recursive generator expression
     (nice and simple code), but recursive generator expressions in python
     perform like your grandma in a counterstrike competition. so now i've
     written the ObjectCollectionIterator, a single object that can iterate
     over an entire tritree without resorting to recursion or generators.
  -- performance fix: rewrote Boundingbox.intersects and .contains for speed.
  -- bug workaround: my tritree ObjectCollection kills bullets that leave the
     level without registering a collision with the level bounds. however,
     it's a bug that this collision isn't registered so often, and we'll have
     to fix that ASAP (e.g. with the sweep tests oneup proposed). as a
     temporary workaround, i now remove bullets that have become too old, just
     like particles.
  -- repeating my ~100 object test from before now gives me ~15fps. this is
     somewhat OK, definitely an improvement over colliding everything with
     everything, but it's way below my expectations. i'm tending to declare my
     experiment a failure. of course this means that i suck, but i also think
     that there's a fundamental problem here: considering how the game is
     currently planned, it'll have to handle hundreds of objects. we can
     always stay well below 1000, no problem, but hundreds we'll get. and i
     don't see a good way of pulling this off with pure python. maybe we
     should do the lower-level stuff in C or something -- or use a library
     which already does that. i've got some sample code lying around somewhere
     that shows how to use PyODE with a 2D game ... anyways, the tritree
     ObjectCollection is a rather small improvement, and the not-yet-cleaned-
     up code is 300 lines of ugly -- oneup will probably almost puke when he
     sees that -- so i'm reluctant to keep using that. on the other hand,
     all the code related to keeping track of what's where and which
     bounding boxes intersect -- putting that in one module is a good change.
     now the gamestate module no longer has silly code that tries, every
     single tick, grabbing each bullet and banging it into every other bullet
     just to see what happens (i.e. nothing). the ObjectCollection takes care
     of that and handles it more smartly. it's also possible to extend that
     class so it can syncronise multiple collections across the network. plus,
     the current dynamic level format is bonkers. most of the collisions we
     get, every tick, are with fucking AIR and have no real consequences.
     as i said, the tritree structure is really good with static objects. once
     we've decomposed the levels into many form-fitting bounding boxes, the
     ObjectCollection might work its magic and really shine. therefore, i'd
     like to keep that code around some more. so, here's the deal: i've
     renamed my class TritreeObjectCollection, and the module now also
     contains an abstract class ObjectCollection with detailed documentation.
     TritreeObjectCollection implements the ObjectCollection interface, but
     so does the new class DictObjectCollection i just wrote. the latter is
     very small and simple and does collisions the way i've done them before.
     it implements the exact same interface as the experimental monster class.
     this means that we can go with the new, improved ObjectCollection
     interface and still throw away the TritreeObjectCollection implementation
     any time we like.
- bugfix: MenuitemGroup called its super's __init__ method (i.e.
  Gameobject.__init__) with the parameters '(x, y), (w, h)'. however, the
  latter expects these parameters in the format '(x, y), w, h'. fixed.
- now that i'm already putting together this monster revision, i'd like to go
  all the way and fix blitting, too. just a little bit. actually, the biggest
  issue i'd been looking forward to turned out to be a non-issue, so i only
  did a few small things:
  -- simple things first: turning vsync off helps a little bit. i don't think
     it makes sense having this turned on while also limiting the frame-rate
     to 30fps, especially not in windowed mode. with all other computations
     tied to the refresh rate, that would be _two_ restrictions that slow the
     game down. anyways, i'm not seing any tearing. (it _is_ double buffered,
     but in order to do v_sync at full speed you'd need triple buffering.)
  -- slightly tweaked animation module: now we no longer bother with blitting
     stuff that's off screen anyways. once we have some proper GL code, it
     might actually be faster to always blit everything, but as it is now, in
     immediate mode, i think view culling is appropriate.
  -- something that had irked me for about a week now: bullets and particles,
     which are a single colour and just 1 and 2 pixels large, respectively,
     are drawn with the texture unit ON. you can imagine how exciting those
     textures look. i wrote a first version of some code that draws these
     things as plain GL_QUADS. it doesn't make too much sense yet, as the code
     would have to be re-arranged a bit in order to minimize GL mode switches,
     but it works and, writing it, i found a way to solve the scrolling
     problem and get rid of all the comments saying "FIXME, stupid scrolling
     system" with about four lines of code: before we draw all the stuff that
     has to be scrolled, we just say:
     glPushMatrix()
     shift = puit.gamemaster.scrollarea.bottom_left
     glTranslatef(-1 * shift[0], -1 * shift[1], 0)
     and when we're done with that stuff, we say:
     glPopMatrix()
     or maybe switch the matrix mode over to VIEW and do
     glTranslatef(shift[0], shift[1], 0)
     i guess in the context of our code, it would work just as well.
- bugfix: there were a few places in the code where it was assumed that
  positions of Gameobjects are interegers -- they aren't! i'm not sure
  whether i caught all of them yet, but, among more minor things, i finally
  found out what caused this severe bug: movement to the left was much faster
  than movement to the right! (by factor 2, IIRC.) the cause was in
  level.py, which has to look up the player position in a collision map.
  for the lookup, the position has to be rounded, of course -- however, the
  rounded value had made it back into the computation for the new positon of
  the object in question! now that the movement speed of 1.5 pixels per tick
  was finally implemented correctly, it turned out that this speed looks like
  shit, as the movements are oddly dithered. it's particularly bad during
  scrolling. i've set the default Character.speed to 2.0 now; feels quite
  good.
- bugfix: i've replumbed the movement system a bit so it no longer ignores
  keypresses. before, key-down events were always handled, but a key that is
  held down doesn't necessarily only become relevant on key-down and key-up.
  rather, the fact that you're pressing right also becomes relevant the
  moment you release left, for example. the new way of handling this uses
  less code, is simpler and more elegant. i haven't yet checked whether
  _absolutely no_ keypresses are ignored now; i think there still is a weak
  spot concerning respawning. but it's significantly better already.
- bugfix: if self.get_kills() == self.next_wave_at:
  come here so i can slap your wrist with a ruler! now fixed:
  if self.get_kills() >= self.next_wave_at:
- the game runs pretty well now and feels OK. finally. whew! but on my G4,
  it's not quite right yet, the frame-rate isn't glued to 30fps at all times.
  during normal gameplay situations, it usually doesn't drop extremely far
  below 30 either any longer, though. this gave me an idea for one more thing:
  the game now checks whether the simulation is keeping up with real time. if
  not, frames are skipped -- i.e. the next game state is computed, but not
  rendered. at most one frames is skipped at a time -- i.e. it'll never happen
  that the simulation keeps falling behind and the screen isn't updated at
  all. originally i had set the maximum frame-skip parameter to 5, but the
  result was way too jerky. game now feels fine for me. on a faster machine,
  it should stay at precisely 30fps at all times.
- bug workaround: until we have proper sweep tests or something for collision
  detection, i've set the width of bullets to 6, which should keep them from
  going straight through enemies without hurting them.
- now that i can finally play the game properly, i want to have some fun with
  it and do one last thing. just a moment ... [an hour later ...] yep,
  ducking bullets works now. it isn't crouching exactly, but rather a prone
  position, which fits the gameplay quite well (you have to stand up in order
  to turn around) and looks super-cute. i've hacked the animation module a bit
  to make this possible; the weapon has to be moved around when lieing down.
  this is just a quick hack and should be cleaned up some time. i'd suggest
  the following solution, which would also allow to change entire graphics and
  animations based on the state of the object to which they belong, instead
  of just shifting around offsets: expand the structure of directories
  containing, say, a weapon, like so:
  weapons:
    animation.ini # <- with additional information for different knife states
    knife:
      0.png
      stab:
        0.png
        1.png
        2.png
  in this example, the file(s) contained directly in the weapon's directory
  are the default sprite/animation. animation.ini contains information about
  whether to use this default set or a different one, based on some state of
  the weapon's wielder, and which offsets to use. subdirectories are for those
  states that need different graphics from the default set, e.g. a stabbing
  animation for a knife. maybe we should implement this after we've switched
  config files over to YAML. the .inis don't allow the nesting of sections,
  which would be a hindrance here. i also changed the graphics for the gun and
  the minigun a bit in order to make them work with going prone; however, i
  was able to do that in such a way that the appearance of standing characters
  has not changed at all. lastly, i changed the collision detection so that
  a bullet doesn't hit you when you're down on the ground and it goes over
  your head. maybe we should change that eventually and just allow the
  bounding box of characters to shrink/grow when their shape changes? anyways,
  for now, you can dodge bullets. i also tried to teach the AiPlayer how to
  do that, but the basterd is cheating somehow and moving around while in the
  prone position -- haven't found the problem yet. added a level that's
  suitable for practicing ducking: level2.png.

## revision 66 (nex):
- bugfix: adding to Gamestate.collideable_objects now delayed as it should be

## revision 65 (nex):
- bugfix: particles now collide with landscape again.
- bugfix: particle memory leak fixed.  (should have been fixed since r51 ;->)

## revision 64 (nex):
- put in collision groups to help with performance. if you'd like to
  familiarise yourself with how stuff works now, do a project-wide find for
  'collision_group' and 'collideable_objects'.

## revision 63 (nex):
- renamed 'aitest' mode to 'sidekick' (internally, it's still known as
  'help').
- for testing, i want a class that is indistinguishable from the Player class
  to the game. this role is now filled, again, by AiPlayer. the computer-
  controlled guy in 'aitest'/'help' mode is now an instance of the AiBuddy
  class.
- wrote new level generation code that makes hillier landscapes, which are
  only visible in the main menu in this revision.
- added new command line option for starting test mode: '-t' or '--test'.
  this takes one argument that specifies the desired game state. the main menu
  is bypassed and the specified state is launched directly; pressing escape
  immediately quits the game. recognises the options 'arcade' and 'sidekick'.
  when the game ends because all players are dead, it is also quit.
- bugfix: Gamestate.get_all() now also returns objects that are instances of
  subclasses of the specified class; not just instances of that specific
  class.

## revision 62 (oneup):
- glitchy hacky fix to the floor glitch. HACK

## revision 61 (oneup):
- saving controls is saving

## revision 60 (oneup):
- huge arcade mode improvements

## revision 59 (oneup):
- by popular demand... large levels

## revision 57 (oneup):
- png based levels v0 (falls through ground sometimes)